<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Ред на обработка (Queueing)</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
<meta name="copyright"     content="This document copyright 2003 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif">
<p>
[<a href="scrub.html">Преди: Пречистване (Scrub)</a>]
[<a href="index.html">Съдържание</a>]
[<a href="nat.html">Следва: NAT</a>]

<p>
<h1><font color="#e00000">PF: Ред на обработка (Queueing)</font></h1>


<hr>

<h3>Съдържание</h3>
<ul>
<li><a href="#queueing">Ред на обработка</a>
<li><a href="#sched">Schedulers</a>
	<ul>
	<li><a href="#cbq">Обработка, базирана на класове (Class Based 
 Queueing)</a>
	<li><a href="#priq">Обработка по приоритет (Priority Queueing)</a>
	<li><a href="#red">Случайно ранно откриване (Random Early Detection)</a>
	<li><a href="#ecn">Задължително уведомяване за претоварване (Explicit
 Congestion Notification)</a>
	</ul>
<li><a href="#altq">Конфигуриране на реда за обработка</a>
<li><a href="#assign">Насочване на трафик към опашка(queue)</a>
<li><a href="#example1">Example #1: Малка, домашна мрежа</a>
<li><a href="#example2">Example #2: Фирмена мрежа</a>
</ul>

<hr>

<a name="queueing"></a>
<h2>Ред на обработка (Queueing)</h2>
<p>
В компютърните мрежи, когато пакетите с данни се изпращат извън дадена
система, те се запазват в опашка(queue), където изчакват обработка от
операционната система. Операционната система избира коя опашка и точно 
кой пакет от нея да бъде обработен. Редът, в който операционната система 
избира пакети за обработка може да се отрази на производителността на 
системата.
Например, представете си потребител, който използва две мрежови приложения:
SSH и FTP. В идеалния случай, SSH пакетите би трябвало да се обработват
преди FTP пакетите, поради чувствителността на SSH към времето:
когато се натисне клавиш от страната на SSH клиента, се очаква веднага
отговор, докато при FTP няколко секунди закъснение в повече не са толкова
от значение. Какво ще се случи обаче, ако router-а, поддържащ тези връзки,
започне да обработва голяма порция от пакетите на FTP връзката, преди
обработката на SSH връзката? Пакетите от SSH връзката ще останат в опашката
(или дори ще бъдат отхвърлени от router-а, ако опашката не е достатъчно
голяма за да ги съхранява), в резултат на което тази връзка ще се забави
или ще бъде прекъсната. Чрез правилен избор на стратегията за реда на 
обработка на пакетите(queueing), пропусквателната способност на мрежата
може да бъде разпределена справедливо между отделните приложения,
потребители и компютри.

<p>
Забележете, че queueing се прилага само за <i>изходящите</i> пакети.
Когато входящ пакет навлезе в даден интерфейс, вече е твърде късно той
да се въвежда в опашка -- той вече е използвал пропусквателната способност
на мрежата за да пристигне до интерфейса, който го е получил. Единственото
решение е да се разреши queueing на някои от разположените преди дадената
система routers, а ако router е системата получила пакета, да се разреши
queueing на вътрешния интерфейс, където пакетите напускат системата.

<a name="sched"></a>
<h2>Schedulers</h2>
Scheduler е този, който решава коя опашка да се обработи и в какъв ред.
По подразбиране OpenBSD използва "Първи влязъл, първи излязъл" 
(First In First Out  - FIFO) дисциплина. FIFO опашките са като опашка в
супермаркет или банка - първо се обслужва този, който първи се е наредил на 
опашката. Когато пристигнат нови пакети, те се добавят в края на опашката.
Когато опашката се напълни, пакетите, които пристигат се отхвърлят. Това е
извесно като "tail-drop".

<p>
OpenBSD поддържа още два допълнителни schedulers:
<ul>
<li>Обработка, базирана на класове (Class Based Queueing)
<li>Обработка по приоритет (Priority Queueing)
</ul>

<a name="cbq"></a>
<h3>Обработка, базирана на класове (Class Based Queueing)</h3>
Обработката, базирана на класове (Class Based Queueing - CBQ) е алгоритъм за
обработка, който разделя пропусквателната способност на мрежовата връзка между
множество опашки или класове. Всяка опашка, има назначен трафик към нея,
избран според началния или краен адрес, номера на порт, протокола и т.н.
Допълнително, опашката може да бъде конфигурирана да заема трафик от своята
опашка-родител, ако тази опашка-родител не се използва напълно.
На опашките се задава също и приоритет, така че пакетите на опашки, съдържащи 
интерактивен трафик, като например SSH, да бъдат обработени преди опашки, 
съдържащи голямо количество пакети, като FTP.

<p>
CBQ се подреждат в йерархия. На върха на йерархията е базовата опашката (root
 queue), която дефинира цялата достъпна пропусквателна способност. 
Опашките-наследници се създават под базовата опашка, като на всяка се
назначава част от цялата пропусквателна способност на базовата опашка. 
Например опашките могат да бъдат дефинирани така:
<dl>
<dd>Базова опашка (Root Queue) (2Mbps)
	<dl>
	<dd>Опашка A (1Mbps)
	<dd>Опашка B (500Kbps)
	<dd>Опашка C (500Kbps)
	</dl>
</dl>
В този случай цялата достъпна пропусквателна способност е установена на
2 мегабита в секунда (Mbps). Тази пропусквателна способност е разпределена
след това между трите опашки-наследници.

<p>
Йерархията може да бъде разширена, като се дефинират още опашки в зададените
по-горе опашки. За да се раздели пропусквателната способност поравно между
различни потребители и техния трафик да се класифицира така, че определени
протоколи да не блокират други поради недостиг на пропусквателна способност,
може да се дефинира структура от опашки от вида:
<dl>
<dd>Базова опашка (Root Queue) (2Mbps)
	<dl>
	<dd>Потребител A (1Mbps)
		<dl>
		<dd>ssh (50Kbps)
		<dd>обемисти протоколи (950Kbps)
		</dl>
	<dd>Потребител B (1Mbps)
		<dl>
		<dd>audio (250Kbps)
		<dd>обемисти протоколи (750Kbps)
			<dl>
			<dd>http (100Kbps)
			<dd>други (650Kbps)
			</dl>
		</dl>
	</dl>
</dl>
Забележете, че на всяко ниво, сумата от пропусквателната способност,
назначена на всички опашки е не повече от пропусквателната способност на
тяхната опашката-родител.

<p>
Опашка може да бъде конфигурирана да заема пропусквателна способност от
своята опашка родител, ако последната има достъпна такава, поради това
че няма опашка-наследник, която да използва тази пропусквателна способност.
Нека имаме система от опашки от вида:
<dl>
<dd>Базова опашка (Root Queue) (2Mbps)
	<dl>
	<dd>Потребител A (1Mbps)
		<dl>
		<dd>ssh (100Kbps)
		<dd>ftp (900Kbps, всема назаем)
		</dl>
	<dd>Потребител B (1Mbps)
	</dl>
</dl>
Ако трафикът в ftp опашката прехвърли 900Kbps и трафикът в опашката на 
потребител A е по-малко от 1Mbps (защото SSH опашката използва по-малко от
назначените и 100Kbps), то ftp опашката ще заеме надхвърлящата 
пропусквателна способност от своята опашка родител - опашката на потребител
A. По този начин ftp опашката, когато е натоварена, може да използва повече 
от назначената и пропусквателна способност. Когато ssh опашката се натовари,
заетата пропусквателна способност ще и бъде върната.

<p>
CBQ назначава на всяка опашка приоритет. При претоварване, опашките с
по-висок приоритет се обслужват преди тези с по-нисък, ако те са наследници
на една и съща опашка-родител (т.е. ако и двете са в един и същ клон от
йерархията). Опашките с еднакъв приоритет се обслужват последователно
(round-robin дисциплина). Например:
<dl>
<dd>Базова опашка (Root Queue) (2Mbps)
	<dl>
	<dd>Потребител A (1Mbps, приоритет 1)
		<dl>
		<dd>ssh (100Kbps, приоритет 5)
		<dd>ftp (900Kbps, приоритет 3)
		</dl>
	<dd>Потребител B (1Mbps, приоритет 1)
	</dl>
</dl>
CBQ ще обработва опашките на потребител A и потребител B последователно
(round-robin) - никоя опашка не се предпочита пред другата. През времето
на обработка на опашката на потребител A, CBQ обработва също и нейните
опашки-наследници. В този случай ssh опашката има по-висок приоритет и ще
бъде обслужена с предимство, преди ftp опашката, ако мрежата е претоварена.
Забележете, че приоритета на ssh и ftp опашките не се сравнява с този на 
опашките на потребител A и потребител B, защото те не са в един клон на
йерархията.

<p>
Повече информация за теорията, която стои зад CBQ, можете да намерите на
<a href="http://www.icir.org/floyd/cbq.html">този адрес</a>.

<a name="priq"></a>
<h3>Обработка по приоритет (Priority Queueing)</h3>
Обработката по приоритет (Priority Queueing  - PRIQ) свързва множество
опашки към даден мрежов интерфейс, като на всяка опашка се назначава
уникално ниво на приоритет. Опашките с по-висок приоритет <i>винаги</i>
се обслужват преди тези с по-нисък приоритет.

<p>
Структурата на опашките при PRIQ е линейна -- не може да дефинирате опашки
в опашки. Дефинира се базовата опашка, която установява цялата достъпна
пропусквателна способност, след което се дефинират опашките-наследници в
нея. Нека имаме следния пример:

<dl>
<dd>Базова опашка (Root Queue) (2Mbps)
	<dl>
	<dd>Опашка A (приоритет 1)
	<dd>Опашка B (приоритет 2)
	<dd>Опашка C (приоритет 3)
	</dl>
</dl>
Базовата опашка е дефинирата с достъпна пропусквателна способност 2Mbps и
три опашки-наследници. Опашката с най-висок приоритет (най-висок номер на
приоритет) се обслужва първа. Когато всички пакети в опашката се обработят,
или ако опашката е празна, PRIQ преминава към следващата опашка с най-висок
приоритет. В дадена опашка пакетите се обработват по дисциплина "Първи влязъл,
първи излязъл" First In First Out (FIFO).

<p>
Трябва да се отбележи, че когато използвате PRIQ трябва много внимателно да
планирате структурата на опашките (и не само тогава - б.пр.). Поради това,
че PRIQ <i>винаги</i> обработва опашката с по-висок приоритет преди тази с
по-нискък, възможно е опашка с висок приоритет да предизвика забавяне или
дори отхвърляне на пакетите от опашка с нисък приоритет, ако тази високо
приоритетна опашка получава постоянен поток от пакети.

<a name="red"></a>
<h3>Случайно ранно откриване (Random Early Detection)</h3>
Случайното ранно откриване (Random Early Detection  - RED) е алгоритъм за 
предотвратяване на претоварване.
Неговата задача е да предпазва мрежата от претоварване, като гарантира, че
опашката няма да се запълни. Предпазването се извъшва чрез постоянно
изчисляване на средната дължина (размера) на опашката и сравняването и с две
прагови стойностти - минимален праг и максимален праг. Ако средната стойност
и под минималния праг, не се отхвърлят пакети. Ако средната стойност е над
максималния лимит, <i>всички</i> пристигнали нови пакети ще бъдат отхвърлени.
Ако средната стойност е между двата лимита, пакети се отхвърлят на базата
на прогнози, базирани на средната дължина на опашката. С други думи, колкото
средната стойност на дължината на опашката се приближава към максималния
лимит, толкова повече пакети се отхвърлят. Когато се отхвърлят пакети, RED
избира случайно от коя връзка да стане това. С по-голяма вероятност ще бъдат
отхвърлени пакети от връзки, използващи по-голяма пропусквателна способност.

<p>
RED е полезен за предотвратяване на ситации, познати като "глобална
синхронизация" (global synchronization), както и защото може да се нагажда
към ненормални промени в трафика. Глобалната синхронизация се дефинира като
загуба на общия КПД, поради отхвърляне на пакети от няколко връзки 
едновременно. Например ако router, обслужващ 10 FTP връзки, се претовари,
и се отхвърлят пакети от всички (или почти всички) връзки (както се случва
при FIFO опашките), общият КПД ще намалее значително. Това не е приемлива
ситуация, защото ще намали полезността на всички FTP връзки, което пък
означава, че мрежата повече няма да бъде използвана максимално. RED 
предотвратява това, като случайно избира връзките, от които да отхвърли
пакети, вместо да избере всички връзки. Връзките, които използват по-голяма
пропусквателна способност, ще бъдат прекъснати с по-голяма вероятност.
Така по-бързо ще се преодолее претоварването и рязкото намаляване на 
полезността на системата ще се избегне. Освен това, RED може да обработва
ненормални отклонения в трафика, защото пакети започват да се отхвърлят
<i>преди</i> опашката да се запълни. Когато отклонениято в трафика се
случи, опашката ще има достатъчно място за да запази постъпващите пакети.

<p>
RED трябва да се използва само ако транспортният протокол може да реагира
на индикаторите за претоварване в мрежата. В повечето случаи това означава
RED да се използва за TCP трафик, но не и за UDP или ICMP трафик.

<p>
Повече информация за теорията, която стои зад RED, можете да намерите на
<a href="http://www.icir.org/floyd/red.html">този адрес</a>.

<a name="ecn"></a>
<h3>Задължително уведомяване за претоварване (Explicit Congestion 
Notification)</h3>
Задължителното уведомяване за претоварване (Explicit Congestion Notification
 - ECN) се използва заедно с RED за да уведоми две системи,
комуникиращи посредством мрежа за всяко претоварване на връзката между тях. 
Това се осъществява като на RED се разрешава да установи специален флаг в
началната част на пакета (header), вместо да отхвърли този пакет. Ако 
изпращащата система поддържа ECN, тя може да прочете този флаг и да съобрази
трафика си.

<p>
За повече информация за ECN, моля обръщайте се към 
<a href="http://www.rfc-editor.org/rfc/rfc3168.txt">RFC 3168</a>.

<a name="altq"></a>
<h2>Конфигуриране на редът за обработка</h2>
От OpenBSD 3.0 
<a href="http://www.csl.sony.co.jp/person/kjc/kjc/software.html#ALTQ"
>Alternate Queueing (ALTQ)</a> реализацията на последователността за обработка
на пакетите е част от основната система. 
От OpenBSD 3.3 ALTQ е интегрирана и в PF.
ALTQ реализацията на OpenBSD поддържа ред за обработка, базиран на класове 
(Class Based Queueing - CBQ) и обработка по приоритет (Priority Queueing - 
PRIQ). Поддържа се също така случайно ранно откриване (Random Early Detection 
 - RED), както и задължително уведомяване за претоварване (Explicit Congestion 
Notification - ECN).

<p>
Поради това, че ALTQ е част от PF, PF трябва да бъде разрешен. Инструкции
как да се разреши PF могат да се намерят в 
<a href="config.html#activate">секцията за конфигуриране на PF</a>.

<p>
Редът за обработка (queueing) се конфигурира в <tt>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3"
>/etc/pf.conf</a></tt>. Възможни са два типа директиви за конфигуриране на
реда за обработка:
<ul>
<li><tt>altq on</tt> - разрешава ред за обработка (queueing) на даден 
интерфейс, дефинира кой scheduler да се използва, създава базовата опашка
(root queue)
<li><tt>queue</tt> - дефинира свойствата на опашка-наследник
</ul>

<p>
Синтаксисът на директивата <tt>altq on</tt> е:
<blockquote>
<tt>
altq on <i>interface scheduler</i> bandwidth <i>bw</i> qlimit 
<i>qlim</i> \<br>
&nbsp;&nbsp;&nbsp;tbrsize <i>size</i> queue { <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>interface</i></tt> - мрежов интерфейс, за който се задава реда на
обработка
<li><tt><i>scheduler</i></tt> - кой scheduler да се използва. Възможни
стойности са
<tt>cbq</tt> and <tt>priq</tt>. Само един scheduler може да бъде активен на
интерфейса в определен момент
<li><tt><i>bw</i></tt> - цялата пропусквателна способност, достъпна за дадения
scheduler. Може да се укаже като: 1) абсолютна стойност с някои от следните
суфикси: b, Kb, Mb, Gb, съответно за битове, килобитове, мегабитове или
гигабитове в секунда, или 2) като процент от пропусквателната способност 
<tt><i>на интерфейса</i></tt>.
<li><tt><i>qlim</i></tt> - максималният брой на пакетите, които да се пазят
в опашката. Този параметър е незадължителен. Стойността по подразбиране е 50.
<li><tt><i>size</i></tt> - размерът на "token bucket regulator" в байтове.
Ако не е указан, размерът се определя на базата на пропусквателната
способност <tt><i>на интерфейса</i></tt>.
<li><tt><i>queue_list</i></tt> - списък на опашките-наследници, които да се
създадат в основната опашка.
</ul>

Например:
<blockquote>
altq on fxp0 cbq bandwidth 2Mb queue { std, ssh, ftp }
</blockquote>
Това разрешава CBQ на интерфейса fxp0. Общата пропусквателна способност се
установява на 2Mbps. Създават се три опашки-наследници: std, ssh, and ftp.

<p>
Синтаксисът на директивата <tt>queue</tt> е:
<blockquote>
<tt>
queue <i>name</i> bandwidth <i>bw</i> priority <i>pri</i> qlimit
<i>qlim</i> \<br>
&nbsp;&nbsp;&nbsp;<i>scheduler</i> ( <i>sched_options</i> )
{ <i>queue_list</i> }
</tt>
</blockquote>

<ul>
<li><tt><i>name</i></tt> - име на опашката. Трябва да отговаря на някоя
опашка от списъка <tt><i>queue_list</i></tt>,  дефиниран в директивата 
<tt>altq on</tt>. Специално за <tt>cbq</tt> името трябва също да съответства
на име от списъка <tt><i>queue_list</i></tt> в предишната <tt>queue</tt>
директива. Имената на опашки не трябва да са по-дълги от 15 символа.
<li><tt><i>bw</i></tt> - цялата пропусквателна способност, достъпна за дадения
scheduler. Може да се укаже като: 1) абсолютна стойност с някои от следните
суфикси: b, Kb, Mb, Gb, съответно за битове, килобитове, мегабитове или
гигабитове в секунда, или 2) като процент от пропусквателната способност 
<tt><i>на интерфейса</i></tt>.
<li><tt><i>pri</i></tt> - приоритет на опашката. За <tt>cbq</tt> приоритетите
са стойностти от 0 до 7, а за <tt>priq</tt> - от 0 до 15. Най-нисък е
приоритет 0. Стойността на приоритета по подразбиране е 1.
<li><tt><i>qlim</i></tt> - максималният брой на пакетите, които да се пазят
в опашката. Стойността по подразбиране е 50.
<li><tt><i>scheduler</i></tt> - кой scheduler да се използва - <tt>cbq</tt> 
или <tt>priq</tt>. 
Трябва да бъде същият като този на основната опашка (root queue).
<li><tt><i>sched_options</i></tt> - могат да се зададат допълнителни опции
за scheduler, за контрол на режима му на работа:
	<ul>
	<li><tt>default</tt> - дефинира опашката по подразбиране, където всички
        неотговарящи на никоя опашка пакети ще бъдат обработвани. Задължително
        е да има (но само една) опашка по подразбиране.
	<li><tt>red</tt> - разрешава Random Early Detection (RED) за тази
        опашка.
	<li><tt>rio</tt> - разрешава RED с IN/OUT. В този режим, RED ще
        поддържа множество средни стойностти за дължина на опашка, както и
        множество прагови стойностти, по една за всяко IP "качество на
        услугата - Quality of Service (QoS)" ниво.
	<li><tt>ecn</tt> - разрешава Explicit Congestion Notification (ECN) за
        тази опашка. <tt>ecn</tt> предполага разрешен <tt>red</tt>.
	<li><tt>borrow</tt> - опашката може да заема пропусквателна способност
        от своя родител. Възможно е само ако се използва 
	<tt>cbq</tt> scheduler.
	</ul>
<li><tt><i>queue_list</i></tt> - списък с опашки-наследници в дадената опашка
<tt><i>queue_list</i></tt> може да се дефинира само ако се използва
<tt>cbq</tt> scheduler.
</ul>

Да продължим с примера, даден по-горе:
<blockquote>
<tt>
queue std          bandwidth 50% cbq(default)<br>
queue ssh          { ssh_login, ssh_bulk }<br>
&nbsp;&nbsp;queue ssh_login  priority 4 cbq(ecn)<br>
&nbsp;&nbsp;queue ssh_bulk   cbq(ecn)<br>
queue ftp          bandwidth 500Kb priority 3 cbq(borrow red)<br>
</tt>
</blockquote>

<p>
Тук се задават параметрите на дефинираната в предишния пример опашка. На
std опашката се задава пропусквателна способност 50% от тази на основната
опашка (root queue) (или с други думи 1Mbps) и тази опашка се дефинира като
опашка по подразбиране. ssh опашката дефинира две опашки-наследници -
ssh_login and ssh_bulk. На ssh_login се задава по-голям приоритет от този
на ssh_bulk, и на двете опашки се разрешава ECN. На FTP опашката се
задава пропусквателна способност 500Kbps и приоритет 3. Тя може също така
да заема пропусквателна способност, когато е възможно и има разрешен RED.

<a name="assign"></a>
<h3>Насочване на трафик към опашка</h3>
<p>
За да се насочи трафик към дадена опашка, 
в <a href="filter.html">правилата за филтриране</a> на PF се добавя ключовата 
дума <tt>queue</tt>. Например, нека имаме правила за филтриране, съдържащи
реда:
<blockquote>
<tt>pass out on fxp0 from any to any port 22</tt>
</blockquote>

<p>
Пакетите, отговарящи на това правило могат да бъдат насочени към дадена
опашка, като се използва ключовата дума <tt>queue</tt>:
<blockquote>
<tt>pass out on fxp0 from any to any port 22 queue ssh</tt>
</blockquote>

<p>
Когато ключовата дума <tt>queue</tt> се използва в <tt>block</tt> директиви,
TCP RST и "ICMP unreachable" пакети, генерирани в отговор, ще бъдат насочени
към дадената опашка.

<p>
Забележете, че маркирането за принадлежност към опашка може да стане на
интерфейс, различен от зададеният в директивата <tt>altq on</tt>:
<blockquote>
<tt> 
altq on fxp0 cbq bandwidth 2Mb queue { std, ftp }<br>
queue std cbq(default)<br>
queue ftp bandwidth 1.5Mb<br>
<br>
pass in on dc0 from any to any port 21 queue ftp<br>
</tt>
</blockquote>

<p>
Реда на обработка са разрешава за fxp0, но маркирането на пакетите става
в dc0. Ако пакети, отговящи на <tt>pass</tt> правилото излизат през fxp0,
интерфейса, те се насочват за обработка към <tt>ftp</tt> опашката. Този
тип задаване на реда за обработка е особено полезен за routers.

<p>
Обикновено с ключовата дума <tt>queue</tt> се задава само едно име на
опашка, но ако е указано и второ име, то ще бъде използвано като име на
опашка за пакети с <a href="http://www.rfc-editor.org/rfc/rfc791.txt">Тип на
услугата (Type ofService  - ToS)</a> "без-забавяне (low-delay)" или за TCP 
ACK пакети без част за данни.
Добър пример може да се види при използването на SSH. SSH login сесиите се
установяват с ToS - low-delay, докато това не се прави за SCP и SFTP
сесиите. PF може да използва тази информация за да насочва пакетите,
принадлежащи към login връзка в различна опашка от всички останали. Това
може да се използва за да се даде приоритет на пакетите от login връзки пред
тези от връзки за трансфер на файлове.
<blockquote>
<tt>pass out on fxp0 from any to any port 22 queue(ssh_bulk, ssh_login)</tt>
</blockquote>

<p>
Това насочва пакетите, принадлежащи към SSH login връзки към ssh_login
опашката и пакетите, принадлежащи към SCP и SFTP връзки - към ssh_bulk
опашката. Така пакетите на SSH login връзките ще бъдат обработени преди
тези от SCP и SFTP връзките, защото ssh_login опашката е с по-висок
приоритет. 

<p>
Насочването на TCP ACK пакети към опашка с по-висок приоритет е полезно
при асиметрични връзки, т.е. при такива с различна пропусквателна способност
за upload и download, каквито са например ADSL линиите. При ADSL линиите,
ако upload каналът е зает максимално и се стартира download, този download
върви много трудно, защото TCP ACK пакетите, които той трябва да изпрати
не могат да си пробият път през претоварения upload канал. Тестовете 
показват, че upload опашката трябва да се установи на стойност, по-малка
от максимално възможната за дадената линия. Например за ADSL линия с 
максимален upload от
640Kbps, основната опашка (root queue) се задава с <tt>bandwidth</tt>
стойност 600Kbps за по-добра производителност. Най-подходящите
стойности за <tt>bandwidth</tt> могат да се установят с проби и грешки.

<p>
Когато ключовата дума <tt>queue</tt> се използва в правила с <tt>keep
state</tt> като например:
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port 22 flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state queue ssh
</tt>
</blockquote>

<p>
PF ще съхрани опашката в запис от таблицата на състоянията, така че пакети,
връщащи се обратно през fxp0, които отговарят на запазената връзка ще бъдат
насочени към ssh опашката. Забележете, че дори ключовата дума <tt>queue</tt> 
да бъде използвана в правила за филтриране на входящия трафик, целта е
всъщност да се укаже опашка за изходящ трафик. Затова правилото по-горе не
обработва входящи пакети.

<a name="example1"></a>
<h2>Пример #1: Малка, домашна мрежа</h2>
<pre>
  
    [ Alice ]    [ Charlie ]
        |             |                              ADSL
     ---+-----+-------+------ dc0 [ OpenBSD ] fxp0 -------- ( Internet )
              |
           [ Bob ]

</pre>

<p>
В този пример OpenBSD се използва за gateway към Интернет на малка домашна
мрежа с три работни станции. gateway извършва филтриране на пакетите и
NAT преобразуване. Връзката към Интернет е ADSL линия с параметри
2Mbps down и 640Kbps up.

<p>
Политиката за реда на обработка на пакетите в тази мрежа:
<ul>
<li>Запази за Bob пропусквателна способност за download от 80Kbps, за да може
той да играе online, без да бъде притесняван когато Alice или Charlie теглят
нещо. Bob да използва повече от 80Kbps когато е възможно.
<li>Интерактивнят SSH и "instant message" трафик да бъде с по-висок приоритет
от обикновения трафик.
<li>DNS заявките и отговорите на тях да бъдат втори по приоритет.
<li>Изходящите TCP ACK пакети да бъдат с най-висок приоритет в целия изходящ
трафик.
</ul>

<p>
Наборът от правила, описан по-долу реализира зададената мрежова политика.
Забележете, че са описани само <tt>pf.conf</tt> директивите, отнасящи се
пряко до описаната политика. Не са описани останалите  
<a href="nat.html">NAT</a>, <a href="rdr.html">RDR</a> и 
<a href="options.html">параметри</a>.

<p>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# разрешава редът за обработка на пакети на външния интерфейс да контролира
# трафика, излизащ към Интернет. използва priq scheduler за да контролира само
# приоритетите. установява пропусквателната способност на 610Kbps за да
# има възможно най-добра производителност на TCP ACK опашката.

altq on fxp0 priq bandwidth 610Kb queue { std_out, ssh_im_out, dns_out, \
	tcp_ack_out }

# дефинира параметрите на опашките-наследници
# std_out      - опашка по подразбиране. всяко от правилата за филтриране 
#                по-долу, ако изрично не указва опашка, ще добави трафик
#                към тази опашка
# ssh_im_out   - интерактивен SSH и трафик от instant messages.
# dns_out      - DNS заявки.
# tcp_ack_out  - TCP ACK пакети без част за данни.

queue std_out     priq(default)
queue ssh_im_out  priority 4 priq(red)
queue dns_out     priority 5
queue tcp_ack_out priority 6

# разрешава реда за обработка на вътрешния интерфейс да контролира трафика
# постъпващ от Интернет. използва се cbq scheduler за контрол на
# пропусквателната способност (максималната и стойност е 2Mbps)

altq on dc0 cbq bandwidth 2Mb queue { std_in, ssh_im_in, dns_in, bob_in }

# define the parameters for the child queues.
# std_in      - опашка по подразбиране. всяко от правилата за филтриране 
#               по-долу, ако изрично не указва опашка, ще добави трафик
#               към тази опашка
# ssh_im_in   - интерактивен SSH и трафик от instant messages.
# dns_in      - DNS заявки.
# bob_in      - пропусквателна способностм запазена за работната станция на
#               Bob. разрешава му се да заема още от опашката-родител

queue std_in    cbq(default)
queue ssh_im_in priority 4
queue dns_in    priority 5
queue bob_in    bandwidth 80Kb cbq(borrow)


# ... във филтриращата секция на pf.conf ...

alice         = "192.168.0.2"
bob           = "192.168.0.3"
charlie       = "192.168.0.4"
local_net     = "192.168.0.0/24"
ssh_ports     = "{ 22 2022 }"
im_ports      = "{ 1863 5190 5222 }"

# входящи правила за филтриране на fxp0
block in on fxp0 all

# изходящи правила за филтриране на fxp0
block out on fxp0 all
pass  out on fxp0 inet proto tcp from (fxp0) to any flags S/SA \
	keep state queue(std_out, tcp_ack_out)
pass  out on fxp0 inet proto { udp icmp } from (fxp0) to any keep state
pass  out on fxp0 inet proto { tcp udp } from (fxp0) to any port domain \
	keep state queue dns_out
pass  out on fxp0 inet proto tcp from (fxp0) to any port $ssh_ports \
	flags S/SA keep state queue(std_out, ssh_im_out)
pass  out on fxp0 inet proto tcp from (fxp0) to any port $im_ports \
	flags S/SA keep state queue(ssh_im_out, tcp_ack_out)

# входящи правила за филтриране на dc0
block in on dc0 all
pass  in on dc0 from $local_net

# изходящи правила за филтриране на dc0
block out on dc0 all
pass  out on dc0 from any to $local_net
pass  out on dc0 proto { tcp udp } from any port domain to $local_net \
	queue dns_in
pass  out on dc0 proto tcp from any port $ssh_ports to $local_net \
	queue(std_in, ssh_im_in)
pass  out on dc0 proto tcp from any port $im_ports to $local_net \
	queue ssh_im_in
pass  out on dc0 from any to $bob queue bob_in
</pre>
</td></tr>
</table>

<a name="example2"></a>
<h2>Пример #2: Фирмена мрежа</h2>
<pre>

  ( IT Dept )  [ Boss's PC ]
       |          |                                   T1
     --+----+-----+---------- dc0 [ OpenBSD ] fxp0 -------- ( Internet )
            |                         fxp1
         [ COMP1 ]    [ WWW ]         /
                         |           / 
                       --+----------' 

</pre>

<p>
В този случай, OpenBSD системата работи като firewall на фирмена мрежа.
Фирмата разполага с WWW сървър в DMZ зоната на своята мрежа, където
клиентите на фирмата upload-ват своите web страници с FTP. ИТ отделът
има своя собствена подмрежа, свързата към главната мрежа. Шефът на фирмата
използва PC от своя кабинет за email и разглеждане на web страници.
Връзката към Интернет е с T1 линия, установена на 1.5Mbps в двете посоки.
Всички мрежови сегменти използват Fast Ethernet (100Mbps).

<p>
Мрежовият администратор се е спрял на следната политика:
<ul>
<li>Ограничава трафика между WWW сървъра и Интернет на 500Kbps в двете 
посоки.
<li>Няма ограничение на пропусквателната способност за трафика между WWW
сървъра и вътрешната мрежа.
<li>На HTTP трафикът между WWW сървъра и Интернет е зададен по-висок приоритет 
в сравнение с останалия трафик между WWW сървъра и Интернет (например 
трафикът от FTP uploads).
<li>Запазва 500Kbps за ИТ отдела, така че те могат навреме да download-ват
последните излезли софтуерни модификации. Те могат да използват допълнителна
пропусквателна способност, когато е достъпна.
<li>Трафикът между компютъра на Шефа и Интернет е с най-висок приоритет в
сравнение с останалия трафик от/към Интернет.
</ul>

<p>
По-долу е описан наборът от правила (ruleset), който реализира зададената
политика. Забележете, че са включени само <tt>pf.conf</tt> директивите,
отнасящи се пряко към политиката по-горе. Не са показани различните
<a href="nat.html">NAT</a>, <a href="rdr.html">RDR</a> правила и
<a href="options.html">параметри</a>.

<p>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# разрешава редът за обработка на външния интерфейс да обработва пакети,
# излизащи навън към Интернет. използва се cbq scheduler, така че да се
# контролира пропусквателната способност на всяка опашка. максималната
# изходяща пропусквателна способност е 1.5Mbps.

altq on fxp0 cbq bandwidth 1.5Mb queue { std_ext, www_ext, boss_ext }

# дефинира параметрите на опашките-наследници
# std_ext        - стандартна опашка. също опашка по подразбиране за целия
#                  изходящ трафик на fxp0.
# www_ext        - опашка-контейнер за заявките към WWW сървъра. ограничение
#                  от 500Kbps.
#   www_ext_http - http трафик от WWW сървъра
#   www_ext_misc - целият останал non-http трафик от WWW сървъра
# boss_ext       - трафик, идващ от компютъра на Шефа

queue std_ext        cbq(default)
queue www_ext        bandwidth 500Kb { www_ext_http, www_ext_misc }
  queue www_ext_http priority 3 cbq(red)
  queue www_ext_misc priority 1
queue boss_ext       priority 3

# разрешава редът за обработка на пакети на вътрешния интерфейс да
# контролира трафика, идващ от Интернет или от DMZ. използва се cbq
# scheduler за да се контролира пропусквателната способност на всяка
# опашка. пропусквателната способност на този интерфейс е установена на
# максимум. трафикът, идващ от DMZ може да използва цялата пропусквателна
# способност, докато трафикът от Интернет е ограничен на 1.0Mbps
# (защото останалите 0.5Mpbs (или 500Kbps) са заделени за fxp1).

altq on dc0 cbq bandwidth 100% queue { net_int, www_int }

# дефиниране на параметрите на опашките-наследници
# net_int    - опашка-контейнер за трафика от Интернет. пропусквателната
#              способност е 1.0Mbps.
#   std_int  - стандартна опашка. също опашка по подразбиране за изходящия
#              трафик на dc0.
#   it_int   - трафик към подмрежата на ИТ отдела.
#   boss_int - трафик към компютра на Шефа.
# www_int    - трафик от WWW сървъра в DMZ.

queue net_int    bandwidth 1.0Mb { std_int, it_int, boss_int }
  queue std_int  cbq(default)
  queue it_int   bandwidth 500Kb cbq(borrow)
  queue boss_int priority 3
queue www_int    cbq(red)

# разрешава редът за обработка на пакетите на DMZ интерфейса да контролира
# трафика, насочен кум WWW сървъра. използва се cbq scheduler, защото е
# необходим контрол на пропусквателната способност, която е установена на
# максимум за този интерфейс. трафикът от вътрешната мрежа може да използва
# цялата пропусквателна способност, докато трафикът от Интернет е ограничен
# на 500Kbps.

altq on fxp1 cbq bandwidth 100% queue { internal_dmz, net_dmz }

# дефиниране на параметрите на опашките-наследници
# internal_dmz   - трафик от вътрешната мрежа.
# net_dmz        - опашка-контейнер за трафика от Интернет.
#   net_dmz_http - http трафик.
#   net_dmz_misc - целият non-http трафик. също опашка по подразбиране

queue internal_dmz      # нищо специално за установяване
queue net_dmz        bandwidth 500Kb { net_dmz_http, net_dmz_misc }
  queue net_dmz_http priority 3 cbq(red)
  queue net_dmz_misc priority 1 cbq(default)


# ... във филтриращата секция на pf.conf ...

main_net  = "192.168.0.0/24"
it_net    = "192.168.1.0/24"
int_nets  = "{ 192.168.0.0/24, 192.168.1.0/24 }"
dmz_net   = "10.0.0.0/24"

boss      = "192.168.0.200"
wwwserv   = "10.0.0.100"

# забрана по подразбиране
block on { fxp0, fxp1, dc0 } all

# правила за филтриране за входящите fxp0 пакети
pass in on fxp0 proto tcp from any to $wwwserv port { 21, \
	&gt; 49151 } flags S/SA keep state queue www_ext_misc
pass in on fxp0 proto tcp from any to $wwwserv port 80 \
	flags S/SA keep state queue www_ext_http

# правила за филтриране за изходящите fxp0 пакети
pass out on fxp0 from $int_nets to any keep state
pass out on fxp0 from $boss to any keep state queue boss_ext

# правила за филтриране за входящите dc0 пакети
pass in on dc0 from $int_nets to any keep state
pass in on dc0 from $it_net to any queue it_int
pass in on dc0 from $boss to any queue boss_int
pass in on dc0 proto tcp from $int_nets to $wwwserv port { 21, 80, \
	&gt; 49151 } flags S/SA keep state queue www_int

# правила за филтриране за изходящите dc0 пакети
pass out on dc0 from dc0 to $int_nets

# filter rules for fxp1 inbound
# правила за филтриране за входящите fxp1 пакети
pass in on fxp1 proto { tcp, udp } from $wwwserv to any port 53 \
	keep state

# правила за филтриране за изходящите fxp1 пакети
pass out on fxp1 proto tcp from any to $wwwserv port { 21, \
	&gt; 49151 } flags S/SA keep state queue net_dmz_misc
pass out on fxp1 proto tcp from any to $wwwserv port 80 \
	flags S/SA keep state queue net_dmz_http
pass out on fxp1 proto tcp from $int_nets to $wwwserv port { 80, \
	21, &gt; 49151 } flags S/SA keep state queue internal_dmz
</pre>
</td></tr>
</table>

<p>
[<a href="scrub.html">Преди: Пречистване(Scrub)</a>]
[<a href="index.html">Съдържание</a>]
[<a href="nat.html">Следва: NAT</a>]


<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Оригинал: [ OpenBSD: queueing.html,v 1.10 2003/06/13 02:54:08 nick Exp ]<br>
$Id: queueing.html,v 1.1 2003/09/26 09:04:52 moo Exp $<br>
$Translation$<br>
$OpenBSD$
</small>

</body>
</html> 
