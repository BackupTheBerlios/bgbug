<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Пример #1: Firewall за дома или за малък офис</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
<meta name="copyright"     content="This document copyright 2003 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif">
<p>
[<a href="authpf.html">Преди: Authpf: Потребителски shell за аутентикиращи
gateways</a>]
[<a href="index.html">Съдържание</a>]

<p>
<h1><font color="#e00000">PF: Пример #1: Firewall за дома или за малък 
офис</font></h1>
<hr>

<h3>Съдържание</h3>
<ul>
<li><a href="#scenario">Заданието</a>
	<ul>
	<li><a href="#network">Мрежата</a>
	<li><a href="#objective">Целите</a>
	<li><a href="#prep">Подготовка</a>
	</ul>
<li><a href="#ruleset">Наборът с правила</a>
	<ul>
	<li><a href="#macros">Макроси</a>
	<li><a href="#options">Параметри</a>
	<li><a href="#scrub">"Пречистване"</a>
	<li><a href="#nat">Трансформация на мрежовия адрес (NAT)</a>
	<li><a href="#rdr">Пренасочване</a>
	<li><a href="#filter">Правила за филтриране</a>
	</ul>
<li><a href="#allrules">Завършеният набор с правила</a>
</ul>

<hr>

<a name="scenario"></a>
<h2>Заданието</h2>
В този пример PF работи на OpenBSD система като 
firewall и NAT gateway за малка мрежа вкъщи или в малък офис.
Необходимо е също да се предостави ограничен достъп до този firewall от
Интернет. Настоящият документ ще опише цялостно необходимия набор с
правила за реализиране на поставената цел.

<a name="network"></a>
<h3>Мрежата</h3>
Мрежата е реализирана както следва:

<pre>
    
  [ COMP1 ]    [ COMP3 ]
      |            |                               ADSL
   ---+------+-----+------- fxp0 [ OpenBSD ] ep0 -------- ( Internet )
             |
         [ COMP2 ]

</pre>

<p>
Броят на компютрите във вътрешната мрежа не е от първостепенна важност,
затова на схемата са показани само 3. Компютрите са обикновени работни
станции, използвани за web, email, chat и т.н. На вътрешната мрежа е
отделен блок от мрежови адреси 192.168.0.0 / 255.255.255.0 .

<p>
OpenBSD системата е Pentium 100 с две мрежови карти: 3com
3c509B (ep0) и Intel EtherExpress Pro/100 (fxp0). Връзката на мрежата към
Интернет е ADSL, като се използва NAT за да се разпредели тази връзка между
всички компютри от вътрешната мрежа. IP адресът на външния интерфейс се
получава динамично от Интернет провайдъра (ISP).

<a name="objective"></a>
<h3>Целите</h3>
Основните цели са:
<ul>
<li>Неограничен достъп за всички компютри от вътрешната мрежа
<li>Използване на "забрана по подразбиране" набор от правила за филтриране
<li>Разрешаване на firewall-ът на следния входящ от Интернет трафик:
	<ul>
	<li>SSH (TCP port 22): ще бъде използван за поддръжка отвън на 
        firewall машината
	<li>Auth/Ident (TCP port 113): използва се от услуги като SMTP
	и IRC
	<li>ICMP Echo Requests: тип на ICMP пакета, използван от
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ping&amp;sektion=8&amp;manpath=OpenBSD+3.3"
>ping(8)</a>
	</ul>
<li>Запазва статистическа информация за външния интерфейс
<li>По подразбиране отговаря с TCP RST или ICMP Unreachable за блокираните
пакети
<li>Наборът с правила да бъде колкото е възможно по-прост и лесен за
управление
</ul>

<a name="prep"></a>
<h3>Подготовка</h3>
Предполага се, че OpenBSD системата е правилно конфигурирана за да 
действа като рутър. Това включва: проверка на IP мрежовите настройки,
връзката към Интернет и установяването на 
<tt>net.inet.ip.forwarding</tt> в "<tt>1</tt>".

<a name="ruleset"></a>
<h2>Наборът с правила</h2>
Следващите стъпки реализират поставените по-горе цели.

<a name="macros"></a>
<h3>Макроси</h3>
За упростяване на четенето и поддръжката на набора с правила са дефинирани
следните макроси:
<blockquote>
<tt>
int_if = "fxp0"<br>
ext_if = "ep0"<br>
<br>
tcp_services = "{ 22, 113 }"<br>
icmp_types = "echoreq"<br>
<br>
priv_nets = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
</tt>
</blockquote>

<p>
Първите два реда задават мрежовите интерфейси, на които ще се реализира
филтрирането. Третият и четвъртият ред съдържат списък с номерата на TCP
портовете на услугите, достъпни за ползване от Интернет (SSH and ident/auth)
и типовете ICMP пакети, на които е разрешено да достигат до firewall машината.
Последният ред дефинира адреса на loopback интерфейса и
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a> блоковете от
адреси.

<p>
<b>Note</b>: Ако ADSL връзката изисква
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8&amp;manpath=OpenBSD+3.3"
>PPPoE</a>, тогава филтрирането и NAT трябва да се реализират на 
<tt>tun0</tt> интерфейса, а <i>не</i> на <tt>ep0</tt>.

<a name="options"></a>
<h3>Параметри</h3>
Следните два параметъра дефинират отговора по подразбиране на 
<tt>block</tt> правилата за филтриране и разрешават събирането на 
статистическа информация за външния интерфейс:
<blockquote>
<tt>
set block-policy return<br>
set loginterface $ext_if
</tt>
</blockquote>

<a name="scrub"></a>
<h3>"Пречистване"</h3>
Няма причина да не използваме препоръчителното пречистване на целия входящ
трафик, затова ето едноредово правило за това:
<blockquote>
<tt>
scrub in all
</tt>
</blockquote>

<a name="nat"></a>
<h3>Трансформация на мрежовия адрес (NAT)</h3>
За да реализираме NAT за цялата вътрешна мрежа се използва <tt>nat</tt> 
правило:
<blockquote>
<tt>
nat on $ext_if from $int_if:network to any -&gt; ($ext_if)
</tt>
</blockquote>

<p>
Поради това, че IP адресът на външния интерфейс се получава динамично,
около името на интерфейса има скоби, за да бъде уведомен PF за промени в
адреса.

<a name="rdr"></a>
<h3>Пренасочване</h3>
Пренасочване е необходимо единственото за
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+3.3"
>ftp-proxy(8)</a>, така че FTP клиентите от вътрешната мрежа да се свързват
безпроблемно с FTP сървърите в Интернет.
<blockquote>
<tt>
rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
</tt>
</blockquote>

<p>
Забележете, че това правило обхваща само връзки към порт 21. Ако
потребителите редовно се свързват с FTP сървърите на други портове, трябва
да се укаже списък с портове, например: <tt>from any to any
port { 21, 2121 }</tt>.

<a name="filter"></a>
<h3>Правила за филтриране</h3>
Нека първо да започнем със забраната по подразбиране:
<blockquote>
<tt>
block all<br>
</tt>
</blockquote>

<p>
На този етап нищо не преминава през firewall-а, дори от вътрешната
мрежа. Правилата, които следват ще отворят firewall-а, както и
необходимите виртуални интерфейси според целите, поставени по-горе.

<p>
Всяка Unix система има "loopback" интерфейс. Това е виртуален мрежов
интерфейс, с помоща на който приложенията в самата система комуникират
помежду си. Обикновено целият трафик на този интерфейс трябва да е
разрешен. В OpenBSD, loopback интерфейса е
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4&amp;manpath=OpenBSD+3.3"
>lo(4)</a>.
<blockquote>
<tt>
pass quick on lo0 all
</tt>
</blockquote>

<p>
След това,
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>
адресите ще бъдат блокирани от навлизане или напускане на външния
интерфейс - пакети от/за тези адреси не би трябвало никога да се 
появяват в Интернет. Филтрирането им ще ни гарантира, че рутерът
няма да "изтърве" такива адреси от вътрешната мрежа, а също и няма
да пропусне такива пакети отвън, насочени за някои от вътрешните
адреси.
<blockquote>
<tt>
block drop in &nbsp;quick on $ext_if from $priv_nets to any<br>
block drop out quick on $ext_if from any to $priv_nets
</tt>
</blockquote>

<p>
Забележете, че <tt>block drop</tt> се използва за да укаже на PF да не
отговаря с TCP RST или ICMP Unreachable пакети. Понеже такива адреси по
принцип не съществуват в Интернет (извън вътрешната мрежа б.пр.) няма
смисъл да се връща отговор към тях.
Параметърът <tt>quick</tt> се използва да укаже на PF да прекрати
обхождането на оставащите правила за филтриране, ако даден пакет отговаря
на зададените по-горе правила за RFC 1918 адреси - пакети за/от
<tt>$priv_nets</tt> мрежите се отхвърлят веднага.

<p>
А сега да отворим портове за достъпните за използване от Интернет 
услуги:
<blockquote>
<tt>
pass in on $ext_if inet proto tcp from any to ($ext_if) \<br>
&nbsp;&nbsp;&nbsp;port $tcp_services flags S/SA keep state
</tt>
</blockquote>

<p>
Указването на мрежови портове в <tt>$tcp_services</tt> макроса прави
възможно отварянето на допълнителни услуги за използване от Интернет
чрез редактиране на макроса и презареждане на набора с правила. По
подобен начин предлаганите UDP услуги също могат да се укажат чрез
създаване на <tt>$udp_services</tt> макрос и добавяне на правило,
подобно на описаното по-горе, но съдържащо <tt>proto udp</tt>.

<p>
ICMP трафика би трябвало да се пропусне:
<blockquote>
<tt>
pass in inet proto icmp all icmp-type $icmp_types keep state
</tt>
</blockquote>

<p>
Подобно на <tt>$tcp_services</tt> макросът и <tt>$icmp_types</tt>
макросът може да бъде лесно редактиран за да се промени типът на
ICMP пакетите, на които е разрешено да достигат системата. Забележете,
че това правило се отнася за всички мрежови интерфейси.

<p>
Освен това трябва да се пропуска трафикът от/за вътрешната мрежа.
Предполага се, че потребителите от вътрешната мрежа знаят какво
правят и няма да са причина за неприятности. Това не винаги е 
правилно допускане. В такъв случай е необходим по-строг набор от
правила.
<blockquote>
<tt>
pass in on $int_if from $int_if:network to any keep state
</tt>
</blockquote>

<p>
Правилото по-горе разрешава на всяка вътрешна машина да изпраща пакети
през firewall-а, но <i>не разрешава</i> на самия firewall да се
свързва към някоя от вътрешните машини. Добра идея ли е това?
Зависи от конкретната ситуация. Ако firewall-ът е също и DHCP сървър,
необходимо е той да "ping"-ва даден адрес за да провери съществуването
му, преди да го предостави за използване. Разрешението за firewall-ът
да се свързва към вътрешни машини дава възможност на този които се е
свързал с ssh към самия firewall да има достъп до тези машини. Не
забравяйте, че да <i> не се разрешава</i> на firewall-а да се свързва
към вътрешни машини не предоставя много по-голяма сигурност - ако
някой е получил достъп до самия firewall, той вероятно може да промени
правилата за филтриране. Добавянето на следното правило разрешава на
firewall-а да се свързва към машини от вътрешната мрежа:
<blockquote>
<tt>
pass out on $int_if from any to $int_if:network keep state
</tt>
</blockquote>

<p>
Забележете, че ако са зададени и двата реда, описани по-горе, не е
необходим параметърът <tt>keep state</tt> - всички пакети ще преминават
на вътрешния интерфейс, защото има редове за пропускането им и в двете
посоки. Ако обаче <i>не е включен</i> <tt>pass out</tt> редът, то
<tt>pass in</tt> редът задължително <i>трябва</i> да включва <tt>keep
state</tt>. Запазването на състоянието подобрява също така и 
производителността - преди да се приложи дадено правило, първо се
проверява таблицата на състоянията и ако се намери запазено състоянието
на даден пакет, то той се пропуска през firewall-а, без да е необходимо
да се изпълняват правилата за филтриране. Това подобрява 
производителността на изключително натоварени firewall-и, но 
разглежданата система е твърде проста за да генерира достатъчно
натоварване.

<p>
Накрая се пропуска изходящият трафик на външния интерфейс:
<blockquote>
<tt>
pass out on $ext_if proto tcp all modulate state flags S/SA<br>
pass out on $ext_if proto { udp, icmp } all keep state
</tt>
</blockquote>

<p>
TCP, UDP и ICMP трафикът може да напуска firewall-а. Запазва се 
информация за състоянието на пакетите за да могат да се пропуснат
върнатите в отговор пакети.

<a name="allrules"></a>
<h2>Завършеният набор с правила</h2>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# макроси
int_if = "fxp0"
ext_if = "ep0"

tcp_services = "{ 22, 113 }"
icmp_types = "echoreq"

priv_nets = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
	  
# параметри
set block-policy return
set loginterface $ext_if

# "пречистване"
scrub in all

# nat/rdr
nat on $ext_if from $int_if:network to any -&gt; ($ext_if)
rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 \
   port 8021

# правила за филтриране
block all

pass quick on lo0 all

block drop in  quick on $ext_if from $priv_nets to any
block drop out quick on $ext_if from any to $priv_nets

pass in on $ext_if inet proto tcp from any to ($ext_if) \
   port $tcp_services flags S/SA keep state

pass in inet proto icmp all icmp-type $icmp_types keep state

pass in  on $int_if from $int_if:network to any keep state
pass out on $int_if from any to $int_if:network keep state

pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state
</pre>
</td></tr>
</table>

<p>
[<a href="authpf.html">Преди: Authpf: Потребителски shell за аутентикиращи
gateways</a>]
[<a href="index.html">Съдържание</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Оригинал: [ OpenBSD: example1.html,v 1.7 2003/06/29 20:28:24 nick Exp ]<br>
$Id: example1.html,v 1.2 2003/11/13 07:54:39 moo Exp $<br>
$Translation$<br>
$OpenBSD$
</small>

</body>
</html> 
